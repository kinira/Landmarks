import { close } from 'fs';

/** Declaration file generated by dts-gen */

export as namespace Neo4jDriver
export = neo4j_driver;



interface Neo4jError extends Error {
    message: string;
    code: string;

    new (message: string, code: string);
}

type VisitorFunc = ((value: Object, key: string, record: Record) => void);


interface Node {
    identity: { low: Number, high: Number };
    
    labels : Array<String>;

    properties : Object;
}


/**
 * Records make up the contents of the {@link Result}, and is how you access
 * the output of a statement. A simple statement might yield a result stream
 * with a single record, for instance:
 * 
 *     MATCH (u:User) RETURN u.name, u.age
 * 
 * This returns a stream of records with two fields, named `u.name` and `u.age`,
 * each record represents one user found by the statement above. You can access
 * the values of each field either by name:
 * 
 *     record.get("u.name")
 * 
 * Or by it's position:
 * 
 *     record.get(0)
 */
declare interface Record {

    new (keys: Array<Object>, fields: Array<any>, fieldLookup: any);

	/**
	 * Run the given function for each field in this record. The function
	 * will get three arguments - the value, the key and this record, in that
	 * order.
	 * 
	 * @param visitor the function to apply to each field.
	 */
    forEach(visitor: VisitorFunc): void;

	/**
	 * Generates an object out of the current Record
	 */
    toObject(): any;

	/**
	 * Get a value from this record, either by index or by field key.
	 * @param {string|Number} key Field key, or the index of the field.
	 */
    get(key: string | number): /* !this._fields.<i> */ Node | any;

	/**
	 * Check if a value from this record, either by index or by field key, exists.
	 * @param {string|Number} key Field key, or the index of the field.
	 */
    has(key: string | number): boolean;
}

interface Auth { }

interface AuthFactory {
    basic: (user: string, password: string) => {};
    custom: (principal, credentials, realm, scheme, parameters) => void;
    kerberos: (base64EncodedTicket: string) => void;
}

interface Observer {
    onNext(record: Record): void;

    onCompleted(metadata: any): void;

    onError(error: Neo4jError): void;
}

interface ConnectionProvider {

}

interface RecordPromiseResult {
    records: Array<Record>;

    summary: ResultSummary;
}

interface Result extends Promise<RecordPromiseResult> {

    /**
     * Stream records to observer as they come in, this is a more efficient method
     * of handling the results, and allows you to handle arbitrarily large results.
     *
     * @param {Object} observer - Observer object
     * @param {function(record: Record)} observer.onNext - Handle records, one by one.
     * @param {function(metadata: Object)} observer.onCompleted - Handle stream tail, the metadata.
     * @param {function(error: {message:string, code:string})} observer.onError - Handle errors.
     * @return
     */
    subscribe(observer: Observer): void;
}

interface ResultSummary {
    /**
  * @constructor
  * @param {string} statement - The statement this summary is for
  * @param {Object} parameters - Parameters for the statement
  * @param {Object} metadata - Statement metadata
  */
    new (statement: string, parameters: Object, metadata: Object);

    updateStatistics;

    notifications;

    resultConsumedAfter: { low: Number, high: Number };

    resultAvailableAfter: { low: Number, high: Number };

    plan: Boolean;

    profile: { operatorType, identifiers, arguments, dbHits, rows, children } | Boolean;

    server: { address: String, version: string };

    statment: { text: string, parameters: Object }

    counters: {
        nodesCreated(): Number,
        nodesDeleted(): Number,
        relationshipsCreated(): Number,
        relationshipsDeleted(): Number,
        propertiesSet(): Number,
        labelsAdded(): Number,
        labelsRemoved(): Number,
        indexesAdded(): Number,
        indexesRemoved(): Number,
        constraintsAdded(): Number,
        constraintsRemoved(): Number
    }

    hasPlan(): Boolean;

    hasProfile(): Boolean;
}

/**
  * A Session instance is used for handling the connection and
  * sending statements through the connection.
  */
interface Session {
    /**
     * @constructor
     * @param {string} mode the default access mode for this session.
     * @param {ConnectionProvider} connectionProvider - the connection provider to acquire connections from.
     * @param {string} [bookmark=undefined] - the initial bookmark for this session.
     * @param {Object} [config={}] - this driver configuration.
     */
    new (mode: string, connectionProvider: ConnectionProvider, bookmark?: string, config?: any);

    /**
     * Run Cypher statement
     * Could be called with a statement object i.e.: {statement: "MATCH ...", parameters: {param: 1}}
     * or with the statement and parameters as separate arguments.
     * @param {mixed} statement - Cypher statement to execute
     * @param {Object} parameters - Map with parameters to use in statement
     * @return {Result} - New Result
     */
    run(command: string, params: any): Result

	/**
	 * Begin a new transaction in this session. A session can have at most one transaction running at a time, if you
	 * want to run multiple concurrent transactions, you should use multiple concurrent sessions.
	 * 
	 * While a transaction is open the session cannot be used to run statements outside the transaction.
	 * 
	 * @param {string} bookmark - a reference to a previous transaction. DEPRECATED: This parameter is deprecated in
	 * favour of {@link Driver#session} that accepts an initial bookmark. Session will ensure that all nested
	 * transactions are chained with bookmarks to guarantee causal consistency.
	 * @returns {Transaction} - New Transaction
	 * @param bookmark 
	 * @return  
	 */
    beginTransaction(bookmark: string): any;

    /**
     * Return the bookmark received following the last completed {@link Transaction}.
     * 
     * @return a reference to a previous transaction
     * @return  
     */
    lastBookmark(): /* !this._lastBookmark */ any;

	/**
	 * Execute given unit of work in a {@link WRITE} transaction.
	 * 
	 * Transaction will automatically be committed unless the given function throws or returns a rejected promise.
	 * Some failures of the given function or the commit itself will be retried with exponential backoff with initial
	 * delay of 1 second and maximum retry time of 30 seconds. Maximum retry time is configurable via driver config's
	 * <code>maxTransactionRetryTime</code> property in milliseconds.
	 * 
	 * @param {function(tx: Transaction): Promise} transactionWork - callback that executes operations against
	 * a given {@link Transaction}.
	 * @return {Promise} resolved promise as returned by the given function or rejected promise when given
	 * function or commit fails.
	 * @param transactionWork 
	 * @return  
	 */
    writeTransaction(transactionWork: {}): Promise<any>;

    close(): void;
}


/**
 * A driver maintains one or more {@link Session}s with a remote
 * Neo4j instance. Through the {@link Session}s you can send statements
 * and retrieve results from the database.
 * 
 * Drivers are reasonably expensive to create - you should strive to keep one
 * driver instance around per Neo4j Instance you connect to.
 */
interface Driver {

    new (url: string, userAgent: string, token: any, config: any);

    /**
     * Acquire a session to communicate with the database. The driver maintains
     * a pool of sessions, so calling this method is normally cheap because you
     * will be pulling a session out of the common pool.
     *
     * This comes with some responsibility - make sure you always call
     * {@link close} when you are done using a session, and likewise,
     * make sure you don't close your session before you are done using it. Once
     * it is returned to the pool, the session will be reset to a clean state and
     * made available for others to use.
     *
     * @param {string} [mode=WRITE] the access mode of this session, allowed values are "READ" and "WRITE".
     * @param {string} [bookmark=null] the initial reference to some previous transaction. Value is optional and
     * absence indicates that that the bookmark does not exist or is unknown.
     * @return {Session} new session.
     */
    session(mode?: string, bookmark?: any): Session;

    close(): void;

    onCompleted: (message: string) => void;

    onError: (error: string) => void;

}

declare const neo4j_driver: {
    v1: {
        Neo4jError: Neo4jError;
        auth: AuthFactory,
        default: {
            Neo4jError: Neo4jError;
            auth: AuthFactory,
            driver: (connection: string, authentication: Auth) => Driver;
            error: {
                PROTOCOL_ERROR: string;
                SERVICE_UNAVAILABLE: string;
                SESSION_EXPIRED: string;
            };
            int: any;
            integer: {
                inSafeRange: any;
                toNumber: any;
                toString: any;
            };
            isInt: any;
            session: {
                READ: string;
                WRITE: string;
            };
            types: {
                Node: any;
                Path: any;
                PathSegment: any;
                Record: any;
                Relationship: any;
                Result: Result;
                ResultSummary: ResultSummary;
                UnboundRelationship: any;
            };
        };
        /**
 * Construct a new Neo4j Driver. This is your main entry point for this
 * library.
 *
 * ## Configuration
 *
 * This function optionally takes a configuration argument. Available configuration
 * options are as follows:
 *
 *     {
 *       // Encryption level: ENCRYPTION_ON or ENCRYPTION_OFF.
 *       encrypted: ENCRYPTION_ON|ENCRYPTION_OFF
 *
 *       // Trust strategy to use if encryption is enabled. There is no mode to disable
 *       // trust other than disabling encryption altogether. The reason for
 *       // this is that if you don't know who you are talking to, it is easy for an
 *       // attacker to hijack your encrypted connection, rendering encryption pointless.
 *       //
 *       // TRUST_ALL_CERTIFICATES is the default choice for NodeJS deployments. It only requires
 *       // new host to provide a certificate and does no verification of the provided certificate.
 *       //
 *       // TRUST_ON_FIRST_USE is available for modern NodeJS deployments, and works
 *       // similarly to how `ssl` works - the first time we connect to a new host,
 *       // we remember the certificate they use. If the certificate ever changes, we
 *       // assume it is an attempt to hijack the connection and require manual intervention.
 *       // This means that by default, connections "just work" while still giving you
 *       // good encrypted protection.
 *       //
 *       // TRUST_CUSTOM_CA_SIGNED_CERTIFICATES is the classic approach to trust verification -
 *       // whenever we establish an encrypted connection, we ensure the host is using
 *       // an encryption certificate that is in, or is signed by, a certificate listed
 *       // as trusted. In the web bundle, this list of trusted certificates is maintained
 *       // by the web browser. In NodeJS, you configure the list with the next config option.
 *       //
 *       // TRUST_SYSTEM_CA_SIGNED_CERTIFICATES meand that you trust whatever certificates
 *       // are in the default certificate chain of th
 *       trust: "TRUST_ALL_CERTIFICATES" | "TRUST_ON_FIRST_USE" | "TRUST_SIGNED_CERTIFICATES" |
  *       "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES" | "TRUST_SYSTEM_CA_SIGNED_CERTIFICATES",
 *
 *       // List of one or more paths to trusted encryption certificates. This only
 *       // works in the NodeJS bundle, and only matters if you use "TRUST_CUSTOM_CA_SIGNED_CERTIFICATES".
 *       // The certificate files should be in regular X.509 PEM format.
 *       // For instance, ['./trusted.pem']
 *       trustedCertificates: [],
 *
 *       // Path to a file where the driver saves hosts it has seen in the past, this is
 *       // very similar to the ssl tool's known_hosts file. Each time we connect to a
 *       // new host, a hash of their certificate is stored along with the domain name and
 *       // port, and this is then used to verify the host certificate does not change.
 *       // This setting has no effect unless TRUST_ON_FIRST_USE is enabled.
 *       knownHosts:"~/.neo4j/known_hosts",
 *
 *       // The max number of connections that are allowed idle in the pool at any time.
 *       // Connection will be destroyed if this threshold is exceeded.
 *       connectionPoolSize: 50,
 *
 *       // Specify the maximum time in milliseconds transactions are allowed to retry via
 *       // {@link Session#readTransaction()} and {@link Session#writeTransaction()} functions. These functions
 *       // will retry the given unit of work on `ServiceUnavailable`, `SessionExpired` and transient errors with
 *       // exponential backoff using initial delay of 1 second. Default value is 30000 which is 30 seconds.
 *       maxTransactionRetryTime: 30000,
 *     }
 *
 * @param {string} url The URL for the Neo4j database, for instance "bolt://localhost"
 * @param {Map<String,String>} authToken Authentication credentials. See {@link auth} for helpers.
 * @param {Object} config Configuration object. See the configuration section above for details.
 * @returns {Driver}
 */
        driver: (connection: string, authentication: Object, config?: Object) => Driver;
        error: {
            PROTOCOL_ERROR: string;
            SERVICE_UNAVAILABLE: string;
            SESSION_EXPIRED: string;
        };
        int: any;
        integer: {
            inSafeRange: any;
            toNumber: any;
            toString: any;
        };
        isInt: any;
        session: {
            READ: string;
            WRITE: string;
        };
        types: {
            Node: any;
            Path: any;
            PathSegment: any;
            Record: Record;
            Relationship: any;
            Result: Result;
            ResultSummary: ResultSummary;
            UnboundRelationship: any;
        };
    };
};

